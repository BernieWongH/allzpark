{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Powerful application launcher with reproducible software environments , for visual effects, feature animation and AAA-games productions. Learn more Download Reproducible Environment Precision authoring. Precision use. Control over the environment within which to run software is critical to the success of any studio working on more than one project, not to mention multiple projects concurrently. Establish complex relationships between software, applications and projects with bleeding-rez , the underlying framework powering Allspark . Dual Representation Allspark is but a shell. Anything done via the GUI is available via the command-line, using standard Rez commands. $ rez env alita maya -q > $ echo \"Hello Rez!\" Hello Rez! Environment Management Preview the environment, prior to launching an application. Make changes interactively as you develop or debug complex dependency chains. Process Management Organise your many running processes in a compact way. Give each instance of Maya a unique name, group them, color them, bring-to-front and mass-kill instances to establish available memory in a hurry. Customisation Full theming support with pre-made color palettes to choose from. Interactively edit the underlying CSS and store them as your own. Drag panels around, establish a super-layout with everything visible at once. Allspark is free and open source (LGPL) Let's get this show on the road Learn more Download","title":"Home"},{"location":"about/","text":"This section outlines the rationale behind Allspark, to help you determine whether or not it is of use to you. Story time When Hannah - working at ILM, Weta, MPC, Framestore, Goodbye Kansas or Double Negative - arrives at work in the morning, she typically types something like this into her console. go gravity maya What this does is put Hannah in the \"context\" of the gravity project. The subsequent call to maya then launches a given application, in this case Autodesk Maya. But which version? And why does it matter? A closer look To better understand what's happening here, let's take a closer look at what these commands do. Following the command go gravity , a few things happen. The argument gravity is correlated to a project (either on disk or database) The project is associated with metadata, detailing what software and versions are in use maya-2015 arnold-4.12 mgear-2.4 fbake-4.1 fasset-1.14 ... The associated software is loaded into command-line environment At this point, the subsequent command maya unambiguously refers to maya-2015 , which is how Framestore - and virtually every visual effects, feature animation, commercial and games facility - is able to tie a specific version of each set of software to a given project. Why is this important? The answer lies in interoperability . You see, whatever comes out of Hannah's department must interoperate with subsequent departments. Like an assembly line, the pace of the line remains consistent till the end, and every tool depends on the output of whatever came before it. This holds true for individual applications, like Maya or Visual Studio, but also sub-components of applications - plug-ins. Take arnold-4.12 as an example. This particular version needs to interoperate with maya-2015 . 2015 2016 2017 2018 2019 maya |--------------------------| arnold-1 |-------| arnold-2 |-----------| arnold-3 |-----------| arnold-4 |----------| In order to leverage maya-2015 for a given project, your choice of arnold is limited to those that support it, or vice versa. interoperable slice maya |-----------------|------|---| arnold-1 |-------| | | arnold-2 |-----------| | | arnold-3 |------|------| arnold-4 |-|------|---| | | This issue is compounded by the number of libraries and plug-ins you use for a given project. Consider openimageio , qt , ilmbase and other off-the-shelf projects you may want to employ in a given project, and you can start to get some idea of how narrow It is then further compounded by in-house development projects, such as your pipeline . None of this would have been a problem, if you were able to say: We will ever only work on a single project at a time We know which versions to use We don't develop any new software ourselves In which case you could simply install each of these applications and get to work. But more often than not, things change. And in order to facilitate this change, there needs to be a system in place to help manage the combinatorial complexity of applications, software, and projects.","title":"About"},{"location":"about/#story-time","text":"When Hannah - working at ILM, Weta, MPC, Framestore, Goodbye Kansas or Double Negative - arrives at work in the morning, she typically types something like this into her console. go gravity maya What this does is put Hannah in the \"context\" of the gravity project. The subsequent call to maya then launches a given application, in this case Autodesk Maya. But which version? And why does it matter?","title":"Story time"},{"location":"about/#a-closer-look","text":"To better understand what's happening here, let's take a closer look at what these commands do. Following the command go gravity , a few things happen. The argument gravity is correlated to a project (either on disk or database) The project is associated with metadata, detailing what software and versions are in use maya-2015 arnold-4.12 mgear-2.4 fbake-4.1 fasset-1.14 ... The associated software is loaded into command-line environment At this point, the subsequent command maya unambiguously refers to maya-2015 , which is how Framestore - and virtually every visual effects, feature animation, commercial and games facility - is able to tie a specific version of each set of software to a given project. Why is this important? The answer lies in interoperability . You see, whatever comes out of Hannah's department must interoperate with subsequent departments. Like an assembly line, the pace of the line remains consistent till the end, and every tool depends on the output of whatever came before it. This holds true for individual applications, like Maya or Visual Studio, but also sub-components of applications - plug-ins. Take arnold-4.12 as an example. This particular version needs to interoperate with maya-2015 . 2015 2016 2017 2018 2019 maya |--------------------------| arnold-1 |-------| arnold-2 |-----------| arnold-3 |-----------| arnold-4 |----------| In order to leverage maya-2015 for a given project, your choice of arnold is limited to those that support it, or vice versa. interoperable slice maya |-----------------|------|---| arnold-1 |-------| | | arnold-2 |-----------| | | arnold-3 |------|------| arnold-4 |-|------|---| | | This issue is compounded by the number of libraries and plug-ins you use for a given project. Consider openimageio , qt , ilmbase and other off-the-shelf projects you may want to employ in a given project, and you can start to get some idea of how narrow It is then further compounded by in-house development projects, such as your pipeline . None of this would have been a problem, if you were able to say: We will ever only work on a single project at a time We know which versions to use We don't develop any new software ourselves In which case you could simply install each of these applications and get to work. But more often than not, things change. And in order to facilitate this change, there needs to be a system in place to help manage the combinatorial complexity of applications, software, and projects.","title":"A closer look"},{"location":"guides/","text":"In development Allspark is currently being developed and is not yet ready for use. If you're interested in early-access to collaborate and or contribute, get in touch . A 1.0 is scheduled for release in early August 2019. Quickstart By the time you're done with this chapter, you'll be able to call the below command, and understand when to use it. rez env allspark pyside2 python-3 -- allspark --root /my/projects Where /my/projects is the absolute path to your project Rez packages. Setup Allspark is all about Rez which is all about managing software, so first thing we need is get Rez setup. pip install bleeding-rez --user rez bind --quickstart git clone https : //github.com/mottosso/rez-scoopz.git git clone https : //github.com/mottosso/rez-pipz.git cd rez-scoopz rez build --install rez env scoopz -- install python git cd ../rez-pipz rez build --install rez env pipz -- install pyside2 allspark And there you have it. rez env pyside2 allspark -- allspark --root Package Path The recommended layout for Rez packages are as follows. int/ Internal projects, such as core_pipeline . You develop and release new versions internally. ext/ External projects, such as pyblish and Qt.py , you typically install these with rez env pipz -- install td/ Packages developed by TDs themselves, such as small utility scripts proj/ Project such as ATC and MST3 app/ Applications, such as maya and nuke converted/ Automatically converted packages from the old Template-based system There are two additional paths. ~/packages Your local development packages, from your home directory ~/.packages Your localised packages Pip Any package from PyPI can be installed using a utility package called pipz . $ rez env pipz -- install pyblish-base --release See rez-pipz for details. Scoop Any package from Scoop can be installed using another utility package called scoopz . $ rez env scoopz -- install python python27 git See rez-scoopz for details. Localisation For greater performance, any package may be localised to your local disk. See rez-localz for details. Example $ rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.75s - Loading Qt.. ok - 6.14s - Loading allspark.. ok - 0.53s - Loading preferences.. ok - 0.00s ------------------------------ Notice how long it took to load Qt , let's localise this. $ rez env localz -- localise PySide2 Now try launching again. $ rez env pyside2 allspark bleeding_rez -- python -m allspark rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.91s - Loading Qt.. ok - 0.36s - Loading allspark.. ok - 0.70s - Loading preferences.. ok - 0.00s ------------------------------ That's much better. Disk Space To save disk space, you can delete any or all localised packages from your ~/.packages path. start % USERPROFILE%\\.packages","title":"Guides"},{"location":"guides/#in-development","text":"Allspark is currently being developed and is not yet ready for use. If you're interested in early-access to collaborate and or contribute, get in touch . A 1.0 is scheduled for release in early August 2019.","title":"In development"},{"location":"guides/#quickstart","text":"By the time you're done with this chapter, you'll be able to call the below command, and understand when to use it. rez env allspark pyside2 python-3 -- allspark --root /my/projects Where /my/projects is the absolute path to your project Rez packages.","title":"Quickstart"},{"location":"guides/#setup","text":"Allspark is all about Rez which is all about managing software, so first thing we need is get Rez setup. pip install bleeding-rez --user rez bind --quickstart git clone https : //github.com/mottosso/rez-scoopz.git git clone https : //github.com/mottosso/rez-pipz.git cd rez-scoopz rez build --install rez env scoopz -- install python git cd ../rez-pipz rez build --install rez env pipz -- install pyside2 allspark And there you have it. rez env pyside2 allspark -- allspark --root","title":"Setup"},{"location":"guides/#package-path","text":"The recommended layout for Rez packages are as follows. int/ Internal projects, such as core_pipeline . You develop and release new versions internally. ext/ External projects, such as pyblish and Qt.py , you typically install these with rez env pipz -- install td/ Packages developed by TDs themselves, such as small utility scripts proj/ Project such as ATC and MST3 app/ Applications, such as maya and nuke converted/ Automatically converted packages from the old Template-based system There are two additional paths. ~/packages Your local development packages, from your home directory ~/.packages Your localised packages","title":"Package Path"},{"location":"guides/#pip","text":"Any package from PyPI can be installed using a utility package called pipz . $ rez env pipz -- install pyblish-base --release See rez-pipz for details.","title":"Pip"},{"location":"guides/#scoop","text":"Any package from Scoop can be installed using another utility package called scoopz . $ rez env scoopz -- install python python27 git See rez-scoopz for details.","title":"Scoop"},{"location":"guides/#localisation","text":"For greater performance, any package may be localised to your local disk. See rez-localz for details. Example $ rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.75s - Loading Qt.. ok - 6.14s - Loading allspark.. ok - 0.53s - Loading preferences.. ok - 0.00s ------------------------------ Notice how long it took to load Qt , let's localise this. $ rez env localz -- localise PySide2 Now try launching again. $ rez env pyside2 allspark bleeding_rez -- python -m allspark rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.91s - Loading Qt.. ok - 0.36s - Loading allspark.. ok - 0.70s - Loading preferences.. ok - 0.00s ------------------------------ That's much better. Disk Space To save disk space, you can delete any or all localised packages from your ~/.packages path. start % USERPROFILE%\\.packages","title":"Localisation"},{"location":"localisation/","text":"Shared packages","title":"Localisation"},{"location":"reference/","text":"Assumptions In order to leverage Allspark, these are the assumptions it makes about your setup. Project Packages MUST be of type FileSystemRepository Allspark MUST distinguish between a Project package and other packages Allspark MAY distinguish between an Application package and other packages Project packages should reside in a single directory; the contents of this folder is what your artists are able to see from Allspark. Project Allspark associates software and applications with a project via a Rez package. mkdir myproject cd myproject \"name = `\" myproject `\" \" | Add-Content package.py \"version = `\" 1.0 `\" \" | Add-Content package.py \"build_command = False\" | Add-Content package.py With a project created, point allspark to it. cd .. rez env allspark --root $(pwd) With this in mind, it is recommended you separate your Project Packages from other packages. PS> tree $(rez config release_packages_path) \u251c\u2500\u2500\u2500proj \u2502 \u2514\u2500\u2500\u2500myproject \u2514\u2500\u2500\u2500other Application Allspark visualises applications relative a given project. A project can specify relevant applications using ~weak references in its requires = [] . name = \"myproject\" version = \"1.0\" build_command = False requires = [ \"~maya-2018\" , \"~nuke-11\" , \"~zbrush-2019\" ] This will result in maya , nuke and zbrush being visualised in Allspark, at these particular versions. Because they are ~weak , Rez can resolve an environment with or without either one, which enables you to specify requirements that conflict across different applications; such as ilmbase-1.1 for Maya and ilmbase-3.6 for Nuke.","title":"Reference"},{"location":"reference/#assumptions","text":"In order to leverage Allspark, these are the assumptions it makes about your setup. Project Packages MUST be of type FileSystemRepository Allspark MUST distinguish between a Project package and other packages Allspark MAY distinguish between an Application package and other packages Project packages should reside in a single directory; the contents of this folder is what your artists are able to see from Allspark.","title":"Assumptions"},{"location":"reference/#project","text":"Allspark associates software and applications with a project via a Rez package. mkdir myproject cd myproject \"name = `\" myproject `\" \" | Add-Content package.py \"version = `\" 1.0 `\" \" | Add-Content package.py \"build_command = False\" | Add-Content package.py With a project created, point allspark to it. cd .. rez env allspark --root $(pwd) With this in mind, it is recommended you separate your Project Packages from other packages. PS> tree $(rez config release_packages_path) \u251c\u2500\u2500\u2500proj \u2502 \u2514\u2500\u2500\u2500myproject \u2514\u2500\u2500\u2500other","title":"Project"},{"location":"reference/#application","text":"Allspark visualises applications relative a given project. A project can specify relevant applications using ~weak references in its requires = [] . name = \"myproject\" version = \"1.0\" build_command = False requires = [ \"~maya-2018\" , \"~nuke-11\" , \"~zbrush-2019\" ] This will result in maya , nuke and zbrush being visualised in Allspark, at these particular versions. Because they are ~weak , Rez can resolve an environment with or without either one, which enables you to specify requirements that conflict across different applications; such as ilmbase-1.1 for Maya and ilmbase-3.6 for Nuke.","title":"Application"},{"location":"rez/","text":"Below you'll find a series of tutorials-by-example of increasing complexity, utilising more of Rez's functionality as we go, solving more and more specific problems. Basics Let's start with the basics. Shortest Possible Example Create and use a new package from scratch in under 40 seconds. mkdir mypackage # Name of your Git project cd mypackage # Rez definition \"name = `\" mypackage `\" \" | Add-Content package.py # Rez package name \"version = `\" 1.0 `\" \" | Add-Content package.py # Rez package version \"build_command = False\" | Add-Content package.py # Called on building package rez build --install # Build package rez env mypackage # Use package > $ # A new environment with your package The > symbol means you are in a Rez \"context\". Type exit to exit the context. Environment Variables Most packages will modify their environment in some way. package.py name = \"mypackage\" version = \"1.1\" build_command = False def commands (): global env # Global variable available to `commands()` env[ \"MYVARIABLE\" ] = \"Yes\" This package will assign \"Yes\" to MYVARIABLE. env A global Python variable representing the environment env[\"MYVARIABLE\"] - An environment variable env.MYVARIABLE - This is also OK $ rez build --install $ rez env mypackage > $ echo % MYVARIABLE% Yes Environment Paths A package can also modify paths, like PATH and PYTHONPATH , without removing what was there before. package.py name = \"mypackage\" version = \"1.2\" build_command = False def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}\" ) env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) This package will assign \"{root}\" to PYTHONPATH . {root} expands to the absolute path to the installed package env[\"PYTHONPATH\"].prepend() - Prepend a value to this variable env[\"PYTHONPATH\"].append() - Append a value to this variable $ rez build --install $ rez env mypackage > $ echo % PYTHONPATH% \\\\server\\packages\\mypackage\\1.2;\\\\server\\packages\\int\\mypackage\\1.2\\python Requirements Most packages will depend on another package. cd mypackage cd .. mkdir mypackage2 touch mypackage2/package.py mypackage2/package.py name = \"mypackage2\" version = \"1.0\" build_command = False requires = [ \"python-3\" , \"mypackage-1.2\" ] This package now requires python-3 and mypackage-1.2 . $ rez build --install $ rez env mypackage2 resolved by manima@toy, on Thu Jun 27 11 : 12 : 18 2019, using Rez v2.32.1 requested packages : mypackage2 ~platform==windows (implicit) ~arch==AMD64 (implicit) ~os==windows-10.0.18362.SP0 (implicit) resolved packages : arch-AMD64 C : \\Users\\manima\\packages\\arch\\AMD64 (local) mypackage-1.3 C : \\Users\\manima\\packages\\mypackage\\1.3 (local) mypackage2-1.0 C : \\Users\\manima\\packages\\mypackage2\\1.0 (local) platform-windows C : \\Users\\manima\\packages\\platform\\windows (local) python-3.7.3 C : \\Users\\manima\\packages\\python\\3.7.3\\platform-windows\\arch-AMD64 (local) > $ Payload Most packages will have additional files, such as Python modules. This is where build_command comes in. $ cd mypackage $ touch install.py # Additional script for build $ mkdir python # Payload directory $ cd python # $ echo print( \"Hello World!\" ) >> mymodule.py # Python payload shipped alongside package package.py name = \"mypackage\" version = \"1.3\" build_command = \"python {root}/install.py\" # Run this command on `rez build` requires = [ \"python-3\" ] def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) # Add payload to environment install.py # This script is called on `rez build` import os import shutil print ( \"Running install.py...\" ) root = os . path . dirname(__file__) build_dir = os . environ[ \"REZ_BUILD_PATH\" ] install_dir = os . environ[ \"REZ_BUILD_INSTALL_PATH\" ] print ( \"Copying payload to %s..\" % build_dir) shutil . copytree( os . path . join(root, \"python\" ), os . path . join(build_dir, \"python\" ), ignore = shutil . ignore_patterns( \"*.pyc\" , \"__pycache__\" ) ) if int(os . getenv( \"REZ_BUILD_INSTALL\" )): # This part is called with `rez build --install` print ( \"Installing payload to %s...\" % install_dir) shutil . copytree( os . path . join(build_dir, \"python\" ), os . path . join(install_dir, \"python\" ), ) Now let's build it. $ rez build --install $ rez env mypackage > $ python -m mymodule Hello World!","title":"Package Management"},{"location":"rez/#basics","text":"Let's start with the basics.","title":"Basics"},{"location":"rez/#shortest-possible-example","text":"Create and use a new package from scratch in under 40 seconds. mkdir mypackage # Name of your Git project cd mypackage # Rez definition \"name = `\" mypackage `\" \" | Add-Content package.py # Rez package name \"version = `\" 1.0 `\" \" | Add-Content package.py # Rez package version \"build_command = False\" | Add-Content package.py # Called on building package rez build --install # Build package rez env mypackage # Use package > $ # A new environment with your package The > symbol means you are in a Rez \"context\". Type exit to exit the context.","title":"Shortest Possible Example"},{"location":"rez/#environment-variables","text":"Most packages will modify their environment in some way. package.py name = \"mypackage\" version = \"1.1\" build_command = False def commands (): global env # Global variable available to `commands()` env[ \"MYVARIABLE\" ] = \"Yes\" This package will assign \"Yes\" to MYVARIABLE. env A global Python variable representing the environment env[\"MYVARIABLE\"] - An environment variable env.MYVARIABLE - This is also OK $ rez build --install $ rez env mypackage > $ echo % MYVARIABLE% Yes","title":"Environment Variables"},{"location":"rez/#environment-paths","text":"A package can also modify paths, like PATH and PYTHONPATH , without removing what was there before. package.py name = \"mypackage\" version = \"1.2\" build_command = False def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}\" ) env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) This package will assign \"{root}\" to PYTHONPATH . {root} expands to the absolute path to the installed package env[\"PYTHONPATH\"].prepend() - Prepend a value to this variable env[\"PYTHONPATH\"].append() - Append a value to this variable $ rez build --install $ rez env mypackage > $ echo % PYTHONPATH% \\\\server\\packages\\mypackage\\1.2;\\\\server\\packages\\int\\mypackage\\1.2\\python","title":"Environment Paths"},{"location":"rez/#requirements","text":"Most packages will depend on another package. cd mypackage cd .. mkdir mypackage2 touch mypackage2/package.py mypackage2/package.py name = \"mypackage2\" version = \"1.0\" build_command = False requires = [ \"python-3\" , \"mypackage-1.2\" ] This package now requires python-3 and mypackage-1.2 . $ rez build --install $ rez env mypackage2 resolved by manima@toy, on Thu Jun 27 11 : 12 : 18 2019, using Rez v2.32.1 requested packages : mypackage2 ~platform==windows (implicit) ~arch==AMD64 (implicit) ~os==windows-10.0.18362.SP0 (implicit) resolved packages : arch-AMD64 C : \\Users\\manima\\packages\\arch\\AMD64 (local) mypackage-1.3 C : \\Users\\manima\\packages\\mypackage\\1.3 (local) mypackage2-1.0 C : \\Users\\manima\\packages\\mypackage2\\1.0 (local) platform-windows C : \\Users\\manima\\packages\\platform\\windows (local) python-3.7.3 C : \\Users\\manima\\packages\\python\\3.7.3\\platform-windows\\arch-AMD64 (local) > $","title":"Requirements"},{"location":"rez/#payload","text":"Most packages will have additional files, such as Python modules. This is where build_command comes in. $ cd mypackage $ touch install.py # Additional script for build $ mkdir python # Payload directory $ cd python # $ echo print( \"Hello World!\" ) >> mymodule.py # Python payload shipped alongside package package.py name = \"mypackage\" version = \"1.3\" build_command = \"python {root}/install.py\" # Run this command on `rez build` requires = [ \"python-3\" ] def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) # Add payload to environment install.py # This script is called on `rez build` import os import shutil print ( \"Running install.py...\" ) root = os . path . dirname(__file__) build_dir = os . environ[ \"REZ_BUILD_PATH\" ] install_dir = os . environ[ \"REZ_BUILD_INSTALL_PATH\" ] print ( \"Copying payload to %s..\" % build_dir) shutil . copytree( os . path . join(root, \"python\" ), os . path . join(build_dir, \"python\" ), ignore = shutil . ignore_patterns( \"*.pyc\" , \"__pycache__\" ) ) if int(os . getenv( \"REZ_BUILD_INSTALL\" )): # This part is called with `rez build --install` print ( \"Installing payload to %s...\" % install_dir) shutil . copytree( os . path . join(build_dir, \"python\" ), os . path . join(install_dir, \"python\" ), ) Now let's build it. $ rez build --install $ rez env mypackage > $ python -m mymodule Hello World!","title":"Payload"}]}