{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Powerful application launcher with reproducible software environments , for visual effects, feature animation and AAA-games productions. Learn more Download Package Based Libraries, applications, projects.. package everything! Allspark is a package-based launcher, which means that everything related to a project is encapsulated into individual, version controlled and dependency managed \"packages\" . Establish complex relationships between software, applications and projects with bleeding-rez , the underlying framework powering Allspark . Dual Representation Allspark is but a shell. Anything done via the GUI is available via the command-line, using standard Rez commands. $ rez env alita maya -q > $ echo \"Hello Rez!\" Hello Rez! Environment Management Preview the environment, prior to launching an application. Make changes interactively as you develop or debug complex dependency chains. Process Management Organise your many running processes in a compact way. Give each instance of Maya a unique name, group them, color them, bring-to-front and mass-kill instances to establish available memory in a hurry. Customisation Full theming support with pre-made color palettes to choose from. Interactively edit the underlying CSS and store them as your own. Drag panels around, establish a super-layout with everything visible at once. Allspark is free and open source (LGPL) Let's get this show on the road Learn more Download","title":"Home"},{"location":"about/","text":"This section outlines the rationale behind Allspark, to help you determine whether or not it is of use to you. Story time When Hannah - working at ILM, Weta, MPC, Framestore, Goodbye Kansas or Double Negative - arrives at work in the morning, she typically types something like this into her console. go gravity maya What this does is put Hannah in the \"context\" of the gravity project. The subsequent call to maya then launches a given application, in this case Autodesk Maya. But which version? And why does it matter? A closer look To better understand what's happening here, let's take a closer look at what these commands do. Following the command go gravity , a few things happen. The argument gravity is correlated to a project (either on disk or database) The project is associated with metadata, detailing what software and versions are in use maya-2015 arnold-4.12 mgear-2.4 fbake-4.1 fasset-1.14 ... The associated software is loaded into command-line environment At this point, the subsequent command maya unambiguously refers to maya-2015 , which is how Framestore - and virtually every visual effects, feature animation, commercial and games facility - is able to tie a specific version of each set of software to a given project. Why is this important? The answer lies in interoperability . You see, whatever comes out of Hannah's department must interoperate with subsequent departments. Like an assembly line, the pace of the line remains consistent till the end, and every tool depends on the output of whatever came before it. This holds true for individual applications, like Maya or Visual Studio, but also sub-components of applications - plug-ins. Take arnold-4.12 as an example. This particular version needs to interoperate with maya-2015 . 2015 2016 2017 2018 2019 maya |--------------------------| arnold-1 |-------| arnold-2 |-----------| arnold-3 |-----------| arnold-4 |----------| In order to leverage maya-2015 for a given project, your choice of arnold is limited to those that support it, or vice versa. interoperable slice maya |-----------------|------|---| arnold-1 |-------| | | arnold-2 |-----------| | | arnold-3 |------|------| arnold-4 |-|------|---| | | This issue is compounded by the number of libraries and plug-ins you use for a given project. Consider openimageio , qt , ilmbase and other off-the-shelf projects you may want to employ in a given project, and you can start to get some idea of how narrow It is then further compounded by in-house development projects, such as your pipeline . None of this would have been a problem, if you were able to say: We will ever only work on a single project at a time We know which versions to use We don't develop any new software ourselves In which case you could simply install each of these applications and get to work. But more often than not, things change. And in order to facilitate this change, there needs to be a system in place to help manage the combinatorial complexity of applications, software, and projects.","title":"About"},{"location":"about/#story-time","text":"When Hannah - working at ILM, Weta, MPC, Framestore, Goodbye Kansas or Double Negative - arrives at work in the morning, she typically types something like this into her console. go gravity maya What this does is put Hannah in the \"context\" of the gravity project. The subsequent call to maya then launches a given application, in this case Autodesk Maya. But which version? And why does it matter?","title":"Story time"},{"location":"about/#a-closer-look","text":"To better understand what's happening here, let's take a closer look at what these commands do. Following the command go gravity , a few things happen. The argument gravity is correlated to a project (either on disk or database) The project is associated with metadata, detailing what software and versions are in use maya-2015 arnold-4.12 mgear-2.4 fbake-4.1 fasset-1.14 ... The associated software is loaded into command-line environment At this point, the subsequent command maya unambiguously refers to maya-2015 , which is how Framestore - and virtually every visual effects, feature animation, commercial and games facility - is able to tie a specific version of each set of software to a given project. Why is this important? The answer lies in interoperability . You see, whatever comes out of Hannah's department must interoperate with subsequent departments. Like an assembly line, the pace of the line remains consistent till the end, and every tool depends on the output of whatever came before it. This holds true for individual applications, like Maya or Visual Studio, but also sub-components of applications - plug-ins. Take arnold-4.12 as an example. This particular version needs to interoperate with maya-2015 . 2015 2016 2017 2018 2019 maya |--------------------------| arnold-1 |-------| arnold-2 |-----------| arnold-3 |-----------| arnold-4 |----------| In order to leverage maya-2015 for a given project, your choice of arnold is limited to those that support it, or vice versa. interoperable slice maya |-----------------|------|---| arnold-1 |-------| | | arnold-2 |-----------| | | arnold-3 |------|------| arnold-4 |-|------|---| | | This issue is compounded by the number of libraries and plug-ins you use for a given project. Consider openimageio , qt , ilmbase and other off-the-shelf projects you may want to employ in a given project, and you can start to get some idea of how narrow It is then further compounded by in-house development projects, such as your pipeline . None of this would have been a problem, if you were able to say: We will ever only work on a single project at a time We know which versions to use We don't develop any new software ourselves In which case you could simply install each of these applications and get to work. But more often than not, things change. And in order to facilitate this change, there needs to be a system in place to help manage the combinatorial complexity of applications, software, and projects.","title":"A closer look"},{"location":"examples/","text":"Learn Allspark by example. This assumes you've already accumulated the knowledge from the guides chapter. Examples This page contains a series of solutions to specific problems. Command Shorthand Use rez env to establish a context, and --command to immediately run a command within that context. rez env --command= \"echo Hello\" Instead of using --command , you can also use -- . rez env -- echo Hello Note that you didn't need quotation marks or an = sign for this to work, and that it's a little easier on the eyes. We use this syntax extensively throughout this guide. External Packages With Rez you can package almost anything, but sometimes there are packages already made for you to benefit from. Install from PyPI Managing external projects is no fun unless you can benefit from what package authors in neighboring ecosystems have been working on. PyPI is such an ecosystem and you can install any package from PyPI as a Rez package using rez-pipz . git clone https://github.com/mottosso/rez-pipz.git cd rez-pipz rez build --install Here's how you use it. rez env pipz -- install six See rez-pipz for details. Install from Scoop Scoop is a package manager for Windows. It's akin to Chocolatey , except packages are portable and doesn't require adminstrative access, which makes it a perfect fit for Rez. git clone https://github.com/mottosso/rez-scoopz.git cd rez-scoopz rez build --install Here's how you use it. rez env scoopz -- install python See rez-scoopz for details. Windows Gotchas Here are a few things to keep in mind when working with Rez on Windows. alias() on Windows with cmd Utilises doskey , which works similar to alias on Linux Does not work with rez env -- arbitrary command Does not carry across shell, e.g. start Does not respect cmd.exe scope, e.g. cmd /Q /K doskey python=c:\\python27\\python.exe $* affects parent too Process Tree Virtualenv is one way of using Rez on Windows, and if you do then the rez.exe executable is generated during pip install and works by spawning a python.exe process, also generated by pip , which in turn calls on your system python.exe . Here's what spawning your own Python session from within a Rez context looks like. cmd and 2,000 characters cmd.exe is both familiar and available on every Windows machine dating back to Windows 95. It does however suffer from one major limitation; environment variables are limited in length to 2,000 characters. It isn't quite as simple as that, as there is a limit in the Windows API, another limit in conhost.exe and yet another in cmd.exe . When using Rez with cmd.exe , it is this limit you must take into consideration, and it is the most limiting of them all. To work around this issue, it is recommended that you use PowerShell on Windows. rezconfig.py default_shell = \"powershell\" platform_map You'll want to use a brutal platform_map for your Windows setup, because of stunts like this. Machine A $ C: \\U sers \\m arcus \\D esktop>systeminfo | findstr /B /C: \"OS Name\" /C: \"OS Version\" OS Name: Microsoft Windows 10 Pro OS Version: 10 .0.17134 N/A Build 17134 $ python >>> import platform >>> platform.platform () 'Windows-8-6.2.9200' >>> from rez.utils.platform_ import platform_ >>> platform_.os 'windows-6.2.9200' Machine B $ C: \\U sers \\m arcus \\D esktop>systeminfo | findstr /B /C: \"OS Name\" /C: \"OS Version\" OS Name: Microsoft Windows 10 Pro OS Version: 10 .0.18362 N/A Build 18362 $ python >>> import platform >>> platform.platform () 'Windows-10-10.0.18362' >>> from rez.utils.platform_ import platform_ >>> platform_.os 'windows-10.0.18362.SP0' rezconfig.py For a platform_map , try this one on for size. I'll make any modern version of Windows (8-10) into Windows 10. platform_map = { \"os\" : { r\"windows-6(.*)\" : r\"windows-10\" , r\"windows-10(.*)\" : r\"windows-10\" , }, } Maya and Quicktime Typically, playblasting to .mp4 or .mov with Maya requires a recent install of Quicktime on the local machine. Let's have a look at how to approach this with Rez. How does one approach this with Rez? Submit a PR today!","title":"Examples"},{"location":"examples/#examples","text":"This page contains a series of solutions to specific problems.","title":"Examples"},{"location":"examples/#command-shorthand","text":"Use rez env to establish a context, and --command to immediately run a command within that context. rez env --command= \"echo Hello\" Instead of using --command , you can also use -- . rez env -- echo Hello Note that you didn't need quotation marks or an = sign for this to work, and that it's a little easier on the eyes. We use this syntax extensively throughout this guide.","title":"Command Shorthand"},{"location":"examples/#external-packages","text":"With Rez you can package almost anything, but sometimes there are packages already made for you to benefit from.","title":"External Packages"},{"location":"examples/#install-from-pypi","text":"Managing external projects is no fun unless you can benefit from what package authors in neighboring ecosystems have been working on. PyPI is such an ecosystem and you can install any package from PyPI as a Rez package using rez-pipz . git clone https://github.com/mottosso/rez-pipz.git cd rez-pipz rez build --install Here's how you use it. rez env pipz -- install six See rez-pipz for details.","title":"Install from PyPI"},{"location":"examples/#install-from-scoop","text":"Scoop is a package manager for Windows. It's akin to Chocolatey , except packages are portable and doesn't require adminstrative access, which makes it a perfect fit for Rez. git clone https://github.com/mottosso/rez-scoopz.git cd rez-scoopz rez build --install Here's how you use it. rez env scoopz -- install python See rez-scoopz for details.","title":"Install from Scoop"},{"location":"examples/#windows-gotchas","text":"Here are a few things to keep in mind when working with Rez on Windows.","title":"Windows Gotchas"},{"location":"examples/#alias-on-windows-with-cmd","text":"Utilises doskey , which works similar to alias on Linux Does not work with rez env -- arbitrary command Does not carry across shell, e.g. start Does not respect cmd.exe scope, e.g. cmd /Q /K doskey python=c:\\python27\\python.exe $* affects parent too","title":"alias() on Windows with cmd"},{"location":"examples/#process-tree","text":"Virtualenv is one way of using Rez on Windows, and if you do then the rez.exe executable is generated during pip install and works by spawning a python.exe process, also generated by pip , which in turn calls on your system python.exe . Here's what spawning your own Python session from within a Rez context looks like.","title":"Process Tree"},{"location":"examples/#cmd-and-2000-characters","text":"cmd.exe is both familiar and available on every Windows machine dating back to Windows 95. It does however suffer from one major limitation; environment variables are limited in length to 2,000 characters. It isn't quite as simple as that, as there is a limit in the Windows API, another limit in conhost.exe and yet another in cmd.exe . When using Rez with cmd.exe , it is this limit you must take into consideration, and it is the most limiting of them all. To work around this issue, it is recommended that you use PowerShell on Windows. rezconfig.py default_shell = \"powershell\"","title":"cmd and 2,000 characters"},{"location":"examples/#platform_map","text":"You'll want to use a brutal platform_map for your Windows setup, because of stunts like this. Machine A $ C: \\U sers \\m arcus \\D esktop>systeminfo | findstr /B /C: \"OS Name\" /C: \"OS Version\" OS Name: Microsoft Windows 10 Pro OS Version: 10 .0.17134 N/A Build 17134 $ python >>> import platform >>> platform.platform () 'Windows-8-6.2.9200' >>> from rez.utils.platform_ import platform_ >>> platform_.os 'windows-6.2.9200' Machine B $ C: \\U sers \\m arcus \\D esktop>systeminfo | findstr /B /C: \"OS Name\" /C: \"OS Version\" OS Name: Microsoft Windows 10 Pro OS Version: 10 .0.18362 N/A Build 18362 $ python >>> import platform >>> platform.platform () 'Windows-10-10.0.18362' >>> from rez.utils.platform_ import platform_ >>> platform_.os 'windows-10.0.18362.SP0' rezconfig.py For a platform_map , try this one on for size. I'll make any modern version of Windows (8-10) into Windows 10. platform_map = { \"os\" : { r\"windows-6(.*)\" : r\"windows-10\" , r\"windows-10(.*)\" : r\"windows-10\" , }, }","title":"platform_map"},{"location":"examples/#maya-and-quicktime","text":"Typically, playblasting to .mp4 or .mov with Maya requires a recent install of Quicktime on the local machine. Let's have a look at how to approach this with Rez. How does one approach this with Rez? Submit a PR today!","title":"Maya and Quicktime"},{"location":"guides/","text":"The starting point to using and understanding Allspark. In development Allspark is currently being developed and is not yet ready for use. If you're interested in early-access to collaborate and or contribute, get in touch . A 1.0 is scheduled for release in early August 2019. Goal Estimated reading time: 20 mins By the time you're done with this chapter, you'll be able to call the below command, and understand what it does. rez env allspark bleeding_rez-2.31+ pyside2 python-3 -- allspark Package Management Allspark isn't just a pretty face, it's the backbone of any competent production studio working in visual effects, feature animation, commercials or games. That backbone is made up of packages . What is a package? A package is a group of files with some metadata attached, declaring a name, version and requirements to other packages. When one package requires another, a requirement hierarchy is formed. For example, consider this requirement. requires = [\"maya-2019\", \"arnold\", \"cmuscle\"] From looking at this, you'd expect a version of arnold and cmuscle compatible with maya-2019 (note that we didn't request a particular version of these). Because only a subset of versions of arnold are compatible with maya-2019 what has to happen is a resolve . Resolve Resolving a request means solving the equation of a requirements hierarchy until exact versions of each package in a request is found, and goes something like this. iteration 01 # maya-2019 arnold cmuscle iteration 02 # maya-2019.0.3 arnold-4.12 cmuscle-1.4 iteration 03 # maya-2019.0.3 arnold-4.12 cmuscle-1.4 libpng-12 libtiff-1 qt-5.12 iteration 04 # maya-2019.0.3 arnold-4.9 cmuscle-1.4 libpng-12 libtiff-1 qt-5.12 qtbase-5.12 qtgui-5-12 openiio-3.41 complete In this example, the first iteration is your original request. The second iteration expands on this request to include specific versions of arnold and cmuscle ; both of which are deemed compatible with maya-2019 . Now things start to get interesting, where did libpng-12 come from?! Well, that's a requirement of arnold-4.12 , so if we want arnold we're going to have to get its other requirements too. But see, now things get even more interesting. arnold-4.12 was just downgraded to arnold-4.9 ! That's because openiio was a requirement of qt and conflicts with arnold-4.12 . As a result, an older version of arnold was picked, one that is compatible with openiio-3.41 . Fun fact That last step is one of the thing that separates Rez from package managers like pip and conda ; the retroactive downgrading of a version to conform to a given constraint. This is one of the things that makes Rez more capable and safer than your typical resolver. As you can see, the number of iterations and complexity therein can grow significantly. It is not uncommon for the number of packages involved to grow into the hundreds and run for dozens to hundreds of iterations per solve, with both off-the-shelf software like above and internally developed projects intermingled. Think about what you would have to go through to solve such a hierarchy yourself - which many do. Prerequisities To resolve requirements, we'll utilise bleeding-rez . pip install bleeding-rez rez bind --quickstart rez --version # bleeding-rez 2.33.1 Troubleshooting pip not found It's possible you have pip installed, just not on your PATH . Try this. python -m pip install bleeding-rez If this doesn't work, let's install pip. Reference curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py Permission denied The above command assumes admin/sudo access to your machine which isn't always the case. If so, you can install Rez using a virtual environment. $ python -m pip install virtualenv $ python -m virtualenv rez-install $ rez-install \\S cripts \\a ctivate ( rez-install ) $ pip install bleeding-rez rez not found If installation went successfully, but you aren't able to call rez then odds are the Python executable path isn't on your PATH . On Windows, this directory is typically at c:\\python37\\scripts but may vary depending on how Python was installed, and varies across platforms. Following the installation of rez , you should have gotten a message about which path was missing from your PATH , you can either add this yourself, or use the virtualenv method from the above Permission denied box. This will make rez available via the command-line and establish a few default \"packages\" in your ~/packages directory, which we'll talk about later. Your first project In order launch an application in the context of a project using Allspark, we must create one. Spiderman Your project will be a directory with a file inside called package.py . mkdir spiderman cd spiderman touch package.py This will create a new file called package.py in your newly created spiderman directory. Edit this file with the following. package.py name = \"spiderman\" version = \"1.0\" build_command = False Now we can \"build\" and make use of it. rez build --install $ rez env spiderman > $ The > character denotes that you are in a Rez \"context\", which is its virtual environment. Environment Let's keep going package.py name = \"spiderman\" version = \"1.1\" build_command = False def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" Now what happens? > $ exit $ rez build --install $ rez env spiderman > $ Write-Host $env:PROJECT_NAME Spiderman Requirements Great, we're now in control over the environment of this package. What about requirements? package.py name = \"spiderman\" version = \"1.2\" build_command = False requires = [ \"texteditor\" ] def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" Now spiderman requires texteditor in order to run. Let's build it. > $ exit $ rez build --install 09 :15:46 ERROR PackageFamilyNotFoundError: package family not found: texteditor Your first application Woops! We haven't got a package for texteditor , let's make one. > $ exit $ cd .. $ mkdir texteditor $ cd texteditor $ touch package.py texteditor/package.py name = \"texteditor\" version = \"1.0\" build_command = False def commands (): import os global alias if os . name == \"nt\" : alias( \"texteditor\" , \"notepad\" ) else : alias( \"texteditor\" , \"nano\" ) Now let's build and use this package. $ rez build --install $ rez env spiderman > $ texteditor Viola, a platform-dependent text editor, tied to a given project. This is one way of tying applications to a project, but we'll look at some more as we go along. In general, you'll want to keep packages self-contained and portable, such that you can deploy them elsewhere. In this case, we utilised a widely accessible application we can expect to exist on almost any workstation. But we aren't always so lucky. Another application Let's make another one to illustrate this point. > $ exit $ cd .. $ mkdir maya $ cd maya $ touch package.py maya/package.py name = \"maya\" version = \"2018.0\" build_command = False def commands (): import os global alias if os . name == \"nt\" : alias( \"maya\" , r\"c:\\program files\\autodesk\\maya2018\\bin\\maya.exe\" ) else : alias( \"maya\" , \"/usr/autodesk/maya2018/bin/maya.bin\" ) In this example, we're making some assumptions that may or may not be appropriate for your environment. If you are in control over workstations and installation paths, then this is fine. But if you can't make that guarantee, you'll care about portability which we'll cover a little later. Exercise Before we move on, make another package for maya-2019 as well in a similar fashion. We'll need this for later. Weak References Let's now update our project to require maya and see what we end up with. spiderman/package.py name = \"spiderman\" version = \"1.3\" build_command = False requires = [ \"texteditor-1\" , \"maya-2018\" ] def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" To run it.. $ rez env spiderman > $ maya > $ texteditor As you can see, you now have both maya and texteditor available, at the same time. This typically is not what you want, and comes with a few gotchas. Consider for example if texteditor had a requirement for another project, such as msvcrt<=2011 , and that maya has a similar but conflicting requirement, such as msvcrt>=2013 . In isolation, this isn't a problem, because you can happily run texteditor without requiring maya and vice versa. But because these are both requirements of spiderman , you've now made spiderman impossible to use. To account for this, we need to use \"weak\" references for both texteditor and maya . spiderman/package.py name = \"spiderman\" version = \"1.4\" build_command = False requires = [ \"~texteditor-1\" , \"~maya-2018\" ] def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" Now when spiderman is requested, neither maya nor texteditor is included. ~/spiderman $ rez build --install ~/spiderman $ rez env spiderman > ~/spiderman $ maya # Unrecognised command Instead, you ask for them as part of your request. > spiderman/ $ exit spiderman/ $ rez env spiderman maya # resolved packages: # maya-2018.0 ~\\packages\\maya\\2018.0 But then, what was the point of making these requirements of spiderman if they weren't going to become part of the resolve unless? Surely you can just leave them out, and include maya in the request? If you notice above, the resolved package was maya-2018 . If it wasn't for this weak reference, Rez would have picked the latest version, maya-2019 . This is how you can tie applications to your project, without including each of them into the same context. Think about how chaotic this would be if your project involved dozens of applications! Allspark So you've made a project and given it a unique environment and applications. What's stopping you from launching these applications directly from the command-line? Why do you need Allspark? You don't! Every command we've typed so far has been entirely in the hands of Rez and you can safely run productions in this way. What Allspark does is put a face on this system, something for the less technical-minded artists to wrap their heads around, and establish a few ground-rules about how to make the most out of Rez. We'll get into these rules a little later, but for now, let's see what Allspark looks like on your machine. For this next part, we'll need git . git --verison # git version 2.16.1 git not found Git is required in later chapters, so you may as well get it up and running right away. https://git-scm.com/ Allspark is a Python package, and whilst we could install it like any other Python package, what we're going to do instead is install it as another Rez package. For that, we'll need pipz . git clone https : //github.com/mottosso/rez-pipz.git cd rez-pipz rez build --install pipz is a wrapper around pip for use with Rez. It can take any request pip can, and turn it into a Rez package. This saves from having to create a Rez package ourselves, when it's already a Python package. Neat! To test out the installation, let's install six as Rez package. rez env pipz -- install six -y This is the equivalent of pip install six . Now let's try it with Allspark. git clone https : //github.com/mottosso/allspark.git rez env pipz -- install ./allspark In this case, we'll install Allspark from the cloned repository directly (as it isn't yet on PyPI). We'll also need a Qt binding. Any binding will do, in this example we'll use PySide2. rez env pipz -- install pyside2 -y And there you have it. We are now ready to launch Allspark. rez env allspark python pyside2 -- allspark --root ~/packages Under Development Shared Packages One of the thing that separates Res from other package managers like virtualenv and conda is that packages you install are shared . Not only can they be shared across multiple machines, but also across multiple operating systems. Once a package has been installed, you'll never have to install it again. It is permanent, immutable in fact. This is how you can build up a personal- or studio-repository of packages that you can build a pipeline upon, making strong and controlled assumptions about what packages are available, which version they are at, and that they are compatible with each other. So far, we've installed all packages into their default location, which is ~/packages . ls $env :USERPROFILE/packages # With PowerShell ls $HOME /packages # With Bash Loading Order If your graphical application depends on Qt.py, then Qt.py needs to be loaded before your application. This is where loading order comes in. By establishing a requirements hierarchy, the order in which libraries load is included for free. Package Path The recommended layout for Rez packages are as follows. int/ Internal projects, such as core_pipeline . You develop and release new versions internally. ext/ External projects, such as pyblish and Qt.py , you typically install these with rez env pipz -- install td/ Packages developed by TDs themselves, such as small utility scripts proj/ Project such as ATC and MST3 app/ Applications, such as maya and nuke converted/ Automatically converted packages from the old Template-based system There are two additional paths. ~/packages Your local development packages, from your home directory ~/.packages Your localised packages Pip Any package from PyPI can be installed using a utility package called pipz . $ rez env pipz -- install pyblish-base --release See rez-pipz for details. Scoop Any package from Scoop can be installed using another utility package called scoopz . $ rez env scoopz -- install python python27 git See rez-scoopz for details. Localisation For greater performance, any package may be localised to your local disk. See rez-localz for details. Example $ rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.75s - Loading Qt.. ok - 6.14s - Loading allspark.. ok - 0.53s - Loading preferences.. ok - 0.00s ------------------------------ Notice how long it took to load Qt , let's localise this. $ rez env localz -- localise PySide2 Now try launching again. $ rez env pyside2 allspark bleeding_rez -- python -m allspark rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.91s - Loading Qt.. ok - 0.36s - Loading allspark.. ok - 0.70s - Loading preferences.. ok - 0.00s ------------------------------ That's much better. Disk Space To save disk space, you can delete any or all localised packages from your ~/.packages path. start % USERPROFILE%\\.packages Overrides Packages, like Python modules, are discovered from a list of paths. If there are identical packages on two or more paths, the first one is picked. We can leverage this behavior to override one package with another. Requirements Overriding requirements enable you to test new packages, or packages of different versions, in an existing project and works like this. Copy project onto local development directory Edit Install If the version remains the same or higher then your edited project is now picked up in place of the original, providing final control over which packages are used in a given project. Environment Overriding environment variables can be achieved in a similar fashion to requirements , but is even more flexible. Packages with regards to environment variables act akin to CSS, or Cascading Style Sheets, from the world wide web in that every change augments - or cascades - a previous change. a/package.py def commands (): global env env[ \"PYTHONPATH\" ] . append( \"/a\" ) b/package.py requires = [ \"a\" ] def commands (): global env env[ \"PYTHONPATH\" ] . append( \"/b\" ) In this example, the package b augments an existing PYTHONPATH created by package a . It does so by appending the value \"/b\" . You can also prepend and overwrite by assigning it directly. env[].append(\"\") env[].prepend(\"\") env[] = \"\" Example - Legacy Viewport We can leverage this behavior to override the behavior of a program using dedicated \"override packages\". maya_legacy_viewport/package.py name = \"maya_legacy_viewport\" version = \"1.0\" requires = [ \"maya\" ] def commands (): global env env[ \"MAYA_ENABLE_LEGACY_VIEWPORT\" ] = \"1\" Including this package in your resolve results in Maya exposing the Legacy Viewport option, to circumvent that pesky Viewport 2.0.","title":"Guide"},{"location":"guides/#in-development","text":"Allspark is currently being developed and is not yet ready for use. If you're interested in early-access to collaborate and or contribute, get in touch . A 1.0 is scheduled for release in early August 2019.","title":"In development"},{"location":"guides/#goal","text":"Estimated reading time: 20 mins By the time you're done with this chapter, you'll be able to call the below command, and understand what it does. rez env allspark bleeding_rez-2.31+ pyside2 python-3 -- allspark","title":"Goal"},{"location":"guides/#package-management","text":"Allspark isn't just a pretty face, it's the backbone of any competent production studio working in visual effects, feature animation, commercials or games. That backbone is made up of packages .","title":"Package Management"},{"location":"guides/#what-is-a-package","text":"A package is a group of files with some metadata attached, declaring a name, version and requirements to other packages. When one package requires another, a requirement hierarchy is formed. For example, consider this requirement. requires = [\"maya-2019\", \"arnold\", \"cmuscle\"] From looking at this, you'd expect a version of arnold and cmuscle compatible with maya-2019 (note that we didn't request a particular version of these). Because only a subset of versions of arnold are compatible with maya-2019 what has to happen is a resolve .","title":"What is a package?"},{"location":"guides/#resolve","text":"Resolving a request means solving the equation of a requirements hierarchy until exact versions of each package in a request is found, and goes something like this. iteration 01 # maya-2019 arnold cmuscle iteration 02 # maya-2019.0.3 arnold-4.12 cmuscle-1.4 iteration 03 # maya-2019.0.3 arnold-4.12 cmuscle-1.4 libpng-12 libtiff-1 qt-5.12 iteration 04 # maya-2019.0.3 arnold-4.9 cmuscle-1.4 libpng-12 libtiff-1 qt-5.12 qtbase-5.12 qtgui-5-12 openiio-3.41 complete In this example, the first iteration is your original request. The second iteration expands on this request to include specific versions of arnold and cmuscle ; both of which are deemed compatible with maya-2019 . Now things start to get interesting, where did libpng-12 come from?! Well, that's a requirement of arnold-4.12 , so if we want arnold we're going to have to get its other requirements too. But see, now things get even more interesting. arnold-4.12 was just downgraded to arnold-4.9 ! That's because openiio was a requirement of qt and conflicts with arnold-4.12 . As a result, an older version of arnold was picked, one that is compatible with openiio-3.41 . Fun fact That last step is one of the thing that separates Rez from package managers like pip and conda ; the retroactive downgrading of a version to conform to a given constraint. This is one of the things that makes Rez more capable and safer than your typical resolver. As you can see, the number of iterations and complexity therein can grow significantly. It is not uncommon for the number of packages involved to grow into the hundreds and run for dozens to hundreds of iterations per solve, with both off-the-shelf software like above and internally developed projects intermingled. Think about what you would have to go through to solve such a hierarchy yourself - which many do.","title":"Resolve"},{"location":"guides/#prerequisities","text":"To resolve requirements, we'll utilise bleeding-rez . pip install bleeding-rez rez bind --quickstart rez --version # bleeding-rez 2.33.1 Troubleshooting pip not found It's possible you have pip installed, just not on your PATH . Try this. python -m pip install bleeding-rez If this doesn't work, let's install pip. Reference curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py Permission denied The above command assumes admin/sudo access to your machine which isn't always the case. If so, you can install Rez using a virtual environment. $ python -m pip install virtualenv $ python -m virtualenv rez-install $ rez-install \\S cripts \\a ctivate ( rez-install ) $ pip install bleeding-rez rez not found If installation went successfully, but you aren't able to call rez then odds are the Python executable path isn't on your PATH . On Windows, this directory is typically at c:\\python37\\scripts but may vary depending on how Python was installed, and varies across platforms. Following the installation of rez , you should have gotten a message about which path was missing from your PATH , you can either add this yourself, or use the virtualenv method from the above Permission denied box. This will make rez available via the command-line and establish a few default \"packages\" in your ~/packages directory, which we'll talk about later.","title":"Prerequisities"},{"location":"guides/#your-first-project","text":"In order launch an application in the context of a project using Allspark, we must create one.","title":"Your first project"},{"location":"guides/#spiderman","text":"Your project will be a directory with a file inside called package.py . mkdir spiderman cd spiderman touch package.py This will create a new file called package.py in your newly created spiderman directory. Edit this file with the following. package.py name = \"spiderman\" version = \"1.0\" build_command = False Now we can \"build\" and make use of it. rez build --install $ rez env spiderman > $ The > character denotes that you are in a Rez \"context\", which is its virtual environment.","title":"Spiderman"},{"location":"guides/#environment","text":"Let's keep going package.py name = \"spiderman\" version = \"1.1\" build_command = False def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" Now what happens? > $ exit $ rez build --install $ rez env spiderman > $ Write-Host $env:PROJECT_NAME Spiderman","title":"Environment"},{"location":"guides/#requirements","text":"Great, we're now in control over the environment of this package. What about requirements? package.py name = \"spiderman\" version = \"1.2\" build_command = False requires = [ \"texteditor\" ] def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" Now spiderman requires texteditor in order to run. Let's build it. > $ exit $ rez build --install 09 :15:46 ERROR PackageFamilyNotFoundError: package family not found: texteditor","title":"Requirements"},{"location":"guides/#your-first-application","text":"Woops! We haven't got a package for texteditor , let's make one. > $ exit $ cd .. $ mkdir texteditor $ cd texteditor $ touch package.py texteditor/package.py name = \"texteditor\" version = \"1.0\" build_command = False def commands (): import os global alias if os . name == \"nt\" : alias( \"texteditor\" , \"notepad\" ) else : alias( \"texteditor\" , \"nano\" ) Now let's build and use this package. $ rez build --install $ rez env spiderman > $ texteditor Viola, a platform-dependent text editor, tied to a given project. This is one way of tying applications to a project, but we'll look at some more as we go along. In general, you'll want to keep packages self-contained and portable, such that you can deploy them elsewhere. In this case, we utilised a widely accessible application we can expect to exist on almost any workstation. But we aren't always so lucky.","title":"Your first application"},{"location":"guides/#another-application","text":"Let's make another one to illustrate this point. > $ exit $ cd .. $ mkdir maya $ cd maya $ touch package.py maya/package.py name = \"maya\" version = \"2018.0\" build_command = False def commands (): import os global alias if os . name == \"nt\" : alias( \"maya\" , r\"c:\\program files\\autodesk\\maya2018\\bin\\maya.exe\" ) else : alias( \"maya\" , \"/usr/autodesk/maya2018/bin/maya.bin\" ) In this example, we're making some assumptions that may or may not be appropriate for your environment. If you are in control over workstations and installation paths, then this is fine. But if you can't make that guarantee, you'll care about portability which we'll cover a little later. Exercise Before we move on, make another package for maya-2019 as well in a similar fashion. We'll need this for later.","title":"Another application"},{"location":"guides/#weak-references","text":"Let's now update our project to require maya and see what we end up with. spiderman/package.py name = \"spiderman\" version = \"1.3\" build_command = False requires = [ \"texteditor-1\" , \"maya-2018\" ] def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" To run it.. $ rez env spiderman > $ maya > $ texteditor As you can see, you now have both maya and texteditor available, at the same time. This typically is not what you want, and comes with a few gotchas. Consider for example if texteditor had a requirement for another project, such as msvcrt<=2011 , and that maya has a similar but conflicting requirement, such as msvcrt>=2013 . In isolation, this isn't a problem, because you can happily run texteditor without requiring maya and vice versa. But because these are both requirements of spiderman , you've now made spiderman impossible to use. To account for this, we need to use \"weak\" references for both texteditor and maya . spiderman/package.py name = \"spiderman\" version = \"1.4\" build_command = False requires = [ \"~texteditor-1\" , \"~maya-2018\" ] def commands (): global env env[ \"PROJECT_NAME\" ] = \"Spiderman\" Now when spiderman is requested, neither maya nor texteditor is included. ~/spiderman $ rez build --install ~/spiderman $ rez env spiderman > ~/spiderman $ maya # Unrecognised command Instead, you ask for them as part of your request. > spiderman/ $ exit spiderman/ $ rez env spiderman maya # resolved packages: # maya-2018.0 ~\\packages\\maya\\2018.0 But then, what was the point of making these requirements of spiderman if they weren't going to become part of the resolve unless? Surely you can just leave them out, and include maya in the request? If you notice above, the resolved package was maya-2018 . If it wasn't for this weak reference, Rez would have picked the latest version, maya-2019 . This is how you can tie applications to your project, without including each of them into the same context. Think about how chaotic this would be if your project involved dozens of applications!","title":"Weak References"},{"location":"guides/#allspark","text":"So you've made a project and given it a unique environment and applications. What's stopping you from launching these applications directly from the command-line? Why do you need Allspark? You don't! Every command we've typed so far has been entirely in the hands of Rez and you can safely run productions in this way. What Allspark does is put a face on this system, something for the less technical-minded artists to wrap their heads around, and establish a few ground-rules about how to make the most out of Rez. We'll get into these rules a little later, but for now, let's see what Allspark looks like on your machine. For this next part, we'll need git . git --verison # git version 2.16.1 git not found Git is required in later chapters, so you may as well get it up and running right away. https://git-scm.com/ Allspark is a Python package, and whilst we could install it like any other Python package, what we're going to do instead is install it as another Rez package. For that, we'll need pipz . git clone https : //github.com/mottosso/rez-pipz.git cd rez-pipz rez build --install pipz is a wrapper around pip for use with Rez. It can take any request pip can, and turn it into a Rez package. This saves from having to create a Rez package ourselves, when it's already a Python package. Neat! To test out the installation, let's install six as Rez package. rez env pipz -- install six -y This is the equivalent of pip install six . Now let's try it with Allspark. git clone https : //github.com/mottosso/allspark.git rez env pipz -- install ./allspark In this case, we'll install Allspark from the cloned repository directly (as it isn't yet on PyPI). We'll also need a Qt binding. Any binding will do, in this example we'll use PySide2. rez env pipz -- install pyside2 -y And there you have it. We are now ready to launch Allspark. rez env allspark python pyside2 -- allspark --root ~/packages","title":"Allspark"},{"location":"guides/#under-development","text":"","title":"Under Development"},{"location":"guides/#shared-packages","text":"One of the thing that separates Res from other package managers like virtualenv and conda is that packages you install are shared . Not only can they be shared across multiple machines, but also across multiple operating systems. Once a package has been installed, you'll never have to install it again. It is permanent, immutable in fact. This is how you can build up a personal- or studio-repository of packages that you can build a pipeline upon, making strong and controlled assumptions about what packages are available, which version they are at, and that they are compatible with each other. So far, we've installed all packages into their default location, which is ~/packages . ls $env :USERPROFILE/packages # With PowerShell ls $HOME /packages # With Bash","title":"Shared Packages"},{"location":"guides/#loading-order","text":"If your graphical application depends on Qt.py, then Qt.py needs to be loaded before your application. This is where loading order comes in. By establishing a requirements hierarchy, the order in which libraries load is included for free.","title":"Loading Order"},{"location":"guides/#package-path","text":"The recommended layout for Rez packages are as follows. int/ Internal projects, such as core_pipeline . You develop and release new versions internally. ext/ External projects, such as pyblish and Qt.py , you typically install these with rez env pipz -- install td/ Packages developed by TDs themselves, such as small utility scripts proj/ Project such as ATC and MST3 app/ Applications, such as maya and nuke converted/ Automatically converted packages from the old Template-based system There are two additional paths. ~/packages Your local development packages, from your home directory ~/.packages Your localised packages","title":"Package Path"},{"location":"guides/#pip","text":"Any package from PyPI can be installed using a utility package called pipz . $ rez env pipz -- install pyblish-base --release See rez-pipz for details.","title":"Pip"},{"location":"guides/#scoop","text":"Any package from Scoop can be installed using another utility package called scoopz . $ rez env scoopz -- install python python27 git See rez-scoopz for details.","title":"Scoop"},{"location":"guides/#localisation","text":"For greater performance, any package may be localised to your local disk. See rez-localz for details. Example $ rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.75s - Loading Qt.. ok - 6.14s - Loading allspark.. ok - 0.53s - Loading preferences.. ok - 0.00s ------------------------------ Notice how long it took to load Qt , let's localise this. $ rez env localz -- localise PySide2 Now try launching again. $ rez env pyside2 allspark bleeding_rez -- python -m allspark rez env pyside2 allspark bleeding_rez -- python -m allspark ============================== allspark (1.1.79) ============================== - Loading Rez.. ok - 0.91s - Loading Qt.. ok - 0.36s - Loading allspark.. ok - 0.70s - Loading preferences.. ok - 0.00s ------------------------------ That's much better. Disk Space To save disk space, you can delete any or all localised packages from your ~/.packages path. start % USERPROFILE%\\.packages","title":"Localisation"},{"location":"guides/#overrides","text":"Packages, like Python modules, are discovered from a list of paths. If there are identical packages on two or more paths, the first one is picked. We can leverage this behavior to override one package with another.","title":"Overrides"},{"location":"guides/#requirements_1","text":"Overriding requirements enable you to test new packages, or packages of different versions, in an existing project and works like this. Copy project onto local development directory Edit Install If the version remains the same or higher then your edited project is now picked up in place of the original, providing final control over which packages are used in a given project.","title":"Requirements"},{"location":"guides/#environment_1","text":"Overriding environment variables can be achieved in a similar fashion to requirements , but is even more flexible. Packages with regards to environment variables act akin to CSS, or Cascading Style Sheets, from the world wide web in that every change augments - or cascades - a previous change. a/package.py def commands (): global env env[ \"PYTHONPATH\" ] . append( \"/a\" ) b/package.py requires = [ \"a\" ] def commands (): global env env[ \"PYTHONPATH\" ] . append( \"/b\" ) In this example, the package b augments an existing PYTHONPATH created by package a . It does so by appending the value \"/b\" . You can also prepend and overwrite by assigning it directly. env[].append(\"\") env[].prepend(\"\") env[] = \"\"","title":"Environment"},{"location":"guides/#example-legacy-viewport","text":"We can leverage this behavior to override the behavior of a program using dedicated \"override packages\". maya_legacy_viewport/package.py name = \"maya_legacy_viewport\" version = \"1.0\" requires = [ \"maya\" ] def commands (): global env env[ \"MAYA_ENABLE_LEGACY_VIEWPORT\" ] = \"1\" Including this package in your resolve results in Maya exposing the Legacy Viewport option, to circumvent that pesky Viewport 2.0.","title":"Example - Legacy Viewport"},{"location":"localisation/","text":"Shared packages","title":"Localisation"},{"location":"reference/","text":"Short bite-sized snippets of information. This builds on information provided in the guides chapter. Assumptions In order to leverage Allspark, these are the assumptions it makes about your setup. Project Packages MUST be of type FileSystemRepository Allspark MUST distinguish between a Project package and other packages Allspark MAY distinguish between an Application package and other packages Project packages should reside in a single directory; the contents of this folder is what your artists are able to see from Allspark. Project Allspark associates software and applications with a project via a Rez package. mkdir myproject cd myproject \"name = `\" myproject `\" \" | Add-Content package.py \"version = `\" 1.0 `\" \" | Add-Content package.py \"build_command = False\" | Add-Content package.py With a project created, point allspark to it. cd .. rez env allspark --root $(pwd) With this in mind, it is recommended you separate your Project Packages from other packages. PS> tree $(rez config release_packages_path) \u251c\u2500\u2500\u2500proj \u2502 \u2514\u2500\u2500\u2500myproject \u2514\u2500\u2500\u2500other Application Allspark visualises applications relative a given project. A project can specify relevant applications using ~weak references in its requires = [] . name = \"myproject\" version = \"1.0\" build_command = False requires = [ \"~maya-2018\" , \"~nuke-11\" , \"~zbrush-2019\" ] This will result in maya , nuke and zbrush being visualised in Allspark, at these particular versions. Because they are ~weak , Rez can resolve an environment with or without either one, which enables you to specify requirements that conflict across different applications; such as ilmbase-1.1 for Maya and ilmbase-3.6 for Nuke. allsparkconfig.py Configure allspark using the allsparkconfig.py . allspark/allsparkconfig.py touch ~/allsparkconfig.py Store in your $HOME directory allspark --config-file path/to/allsparkconfig.py Or pass directly \"\"\"The Allspark configuration file Copy this onto your local drive and make modifications. Anything not specified in your copy is inherited from here. ALLSPARK_CONFIG_FILE=/path/to/allsparkconfig.py \"\"\" # Absolute path to where project packages reside # Allspark uses this to establish a listing or available projects projects_dir = \"~/projects\" # Absolute path to where applicaion packages reside # Allspark optionally uses this to enable the \"Show all apps\" button applications_dir = None # (optional) # Load this project on startup. # Defaults to the first available from `projects_dir` startup_application = None # (optional) # Pre-select this application in the list of applications, # if it exists in the startup project. startup_project = None # (optional)","title":"Reference"},{"location":"reference/#assumptions","text":"In order to leverage Allspark, these are the assumptions it makes about your setup. Project Packages MUST be of type FileSystemRepository Allspark MUST distinguish between a Project package and other packages Allspark MAY distinguish between an Application package and other packages Project packages should reside in a single directory; the contents of this folder is what your artists are able to see from Allspark.","title":"Assumptions"},{"location":"reference/#project","text":"Allspark associates software and applications with a project via a Rez package. mkdir myproject cd myproject \"name = `\" myproject `\" \" | Add-Content package.py \"version = `\" 1.0 `\" \" | Add-Content package.py \"build_command = False\" | Add-Content package.py With a project created, point allspark to it. cd .. rez env allspark --root $(pwd) With this in mind, it is recommended you separate your Project Packages from other packages. PS> tree $(rez config release_packages_path) \u251c\u2500\u2500\u2500proj \u2502 \u2514\u2500\u2500\u2500myproject \u2514\u2500\u2500\u2500other","title":"Project"},{"location":"reference/#application","text":"Allspark visualises applications relative a given project. A project can specify relevant applications using ~weak references in its requires = [] . name = \"myproject\" version = \"1.0\" build_command = False requires = [ \"~maya-2018\" , \"~nuke-11\" , \"~zbrush-2019\" ] This will result in maya , nuke and zbrush being visualised in Allspark, at these particular versions. Because they are ~weak , Rez can resolve an environment with or without either one, which enables you to specify requirements that conflict across different applications; such as ilmbase-1.1 for Maya and ilmbase-3.6 for Nuke.","title":"Application"},{"location":"reference/#allsparkconfigpy","text":"Configure allspark using the allsparkconfig.py . allspark/allsparkconfig.py touch ~/allsparkconfig.py Store in your $HOME directory allspark --config-file path/to/allsparkconfig.py Or pass directly \"\"\"The Allspark configuration file Copy this onto your local drive and make modifications. Anything not specified in your copy is inherited from here. ALLSPARK_CONFIG_FILE=/path/to/allsparkconfig.py \"\"\" # Absolute path to where project packages reside # Allspark uses this to establish a listing or available projects projects_dir = \"~/projects\" # Absolute path to where applicaion packages reside # Allspark optionally uses this to enable the \"Show all apps\" button applications_dir = None # (optional) # Load this project on startup. # Defaults to the first available from `projects_dir` startup_application = None # (optional) # Pre-select this application in the list of applications, # if it exists in the startup project. startup_project = None # (optional)","title":"allsparkconfig.py"},{"location":"rez/","text":"Below you'll find a series of tutorials-by-example of increasing complexity, utilising more of Rez's functionality as we go, solving more and more specific problems. Basics Let's start with the basics. Shortest Possible Example Create and use a new package from scratch in under 40 seconds. mkdir mypackage # Name of your Git project cd mypackage # Rez definition \"name = `\" mypackage `\" \" | Add-Content package.py # Rez package name \"version = `\" 1.0 `\" \" | Add-Content package.py # Rez package version \"build_command = False\" | Add-Content package.py # Called on building package rez build --install # Build package rez env mypackage # Use package > $ # A new environment with your package The > symbol means you are in a Rez \"context\". Type exit to exit the context. Environment Variables Most packages will modify their environment in some way. package.py name = \"mypackage\" version = \"1.1\" build_command = False def commands (): global env # Global variable available to `commands()` env[ \"MYVARIABLE\" ] = \"Yes\" This package will assign \"Yes\" to MYVARIABLE. env A global Python variable representing the environment env[\"MYVARIABLE\"] - An environment variable env.MYVARIABLE - This is also OK $ rez build --install $ rez env mypackage > $ echo % MYVARIABLE% Yes Environment Paths A package can also modify paths, like PATH and PYTHONPATH , without removing what was there before. package.py name = \"mypackage\" version = \"1.2\" build_command = False def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}\" ) env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) This package will assign \"{root}\" to PYTHONPATH . {root} expands to the absolute path to the installed package env[\"PYTHONPATH\"].prepend() - Prepend a value to this variable env[\"PYTHONPATH\"].append() - Append a value to this variable $ rez build --install $ rez env mypackage > $ echo % PYTHONPATH% \\\\server\\packages\\mypackage\\1.2;\\\\server\\packages\\int\\mypackage\\1.2\\python Requirements Most packages will depend on another package. cd mypackage cd .. mkdir mypackage2 touch mypackage2/package.py mypackage2/package.py name = \"mypackage2\" version = \"1.0\" build_command = False requires = [ \"python-3\" , \"mypackage-1.2\" ] This package now requires python-3 and mypackage-1.2 . $ rez build --install $ rez env mypackage2 resolved by manima@toy, on Thu Jun 27 11 : 12 : 18 2019, using Rez v2.32.1 requested packages : mypackage2 ~platform==windows (implicit) ~arch==AMD64 (implicit) ~os==windows-10.0.18362.SP0 (implicit) resolved packages : arch-AMD64 C : \\Users\\manima\\packages\\arch\\AMD64 (local) mypackage-1.3 C : \\Users\\manima\\packages\\mypackage\\1.3 (local) mypackage2-1.0 C : \\Users\\manima\\packages\\mypackage2\\1.0 (local) platform-windows C : \\Users\\manima\\packages\\platform\\windows (local) python-3.7.3 C : \\Users\\manima\\packages\\python\\3.7.3\\platform-windows\\arch-AMD64 (local) > $ Payload Most packages will have additional files, such as Python modules. This is where build_command comes in. $ cd mypackage $ touch install.py # Additional script for build $ mkdir python # Payload directory $ cd python # $ echo print( \"Hello World!\" ) >> mymodule.py # Python payload shipped alongside package package.py name = \"mypackage\" version = \"1.3\" build_command = \"python {root}/install.py\" # Run this command on `rez build` requires = [ \"python-3\" ] def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) # Add payload to environment install.py # This script is called on `rez build` import os import shutil print ( \"Running install.py...\" ) root = os . path . dirname(__file__) build_dir = os . environ[ \"REZ_BUILD_PATH\" ] install_dir = os . environ[ \"REZ_BUILD_INSTALL_PATH\" ] print ( \"Copying payload to %s..\" % build_dir) shutil . copytree( os . path . join(root, \"python\" ), os . path . join(build_dir, \"python\" ), ignore = shutil . ignore_patterns( \"*.pyc\" , \"__pycache__\" ) ) if int(os . getenv( \"REZ_BUILD_INSTALL\" )): # This part is called with `rez build --install` print ( \"Installing payload to %s...\" % install_dir) shutil . copytree( os . path . join(build_dir, \"python\" ), os . path . join(install_dir, \"python\" ), ) Now let's build it. $ rez build --install $ rez env mypackage > $ python -m mymodule Hello World!","title":"Packaging"},{"location":"rez/#basics","text":"Let's start with the basics.","title":"Basics"},{"location":"rez/#shortest-possible-example","text":"Create and use a new package from scratch in under 40 seconds. mkdir mypackage # Name of your Git project cd mypackage # Rez definition \"name = `\" mypackage `\" \" | Add-Content package.py # Rez package name \"version = `\" 1.0 `\" \" | Add-Content package.py # Rez package version \"build_command = False\" | Add-Content package.py # Called on building package rez build --install # Build package rez env mypackage # Use package > $ # A new environment with your package The > symbol means you are in a Rez \"context\". Type exit to exit the context.","title":"Shortest Possible Example"},{"location":"rez/#environment-variables","text":"Most packages will modify their environment in some way. package.py name = \"mypackage\" version = \"1.1\" build_command = False def commands (): global env # Global variable available to `commands()` env[ \"MYVARIABLE\" ] = \"Yes\" This package will assign \"Yes\" to MYVARIABLE. env A global Python variable representing the environment env[\"MYVARIABLE\"] - An environment variable env.MYVARIABLE - This is also OK $ rez build --install $ rez env mypackage > $ echo % MYVARIABLE% Yes","title":"Environment Variables"},{"location":"rez/#environment-paths","text":"A package can also modify paths, like PATH and PYTHONPATH , without removing what was there before. package.py name = \"mypackage\" version = \"1.2\" build_command = False def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}\" ) env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) This package will assign \"{root}\" to PYTHONPATH . {root} expands to the absolute path to the installed package env[\"PYTHONPATH\"].prepend() - Prepend a value to this variable env[\"PYTHONPATH\"].append() - Append a value to this variable $ rez build --install $ rez env mypackage > $ echo % PYTHONPATH% \\\\server\\packages\\mypackage\\1.2;\\\\server\\packages\\int\\mypackage\\1.2\\python","title":"Environment Paths"},{"location":"rez/#requirements","text":"Most packages will depend on another package. cd mypackage cd .. mkdir mypackage2 touch mypackage2/package.py mypackage2/package.py name = \"mypackage2\" version = \"1.0\" build_command = False requires = [ \"python-3\" , \"mypackage-1.2\" ] This package now requires python-3 and mypackage-1.2 . $ rez build --install $ rez env mypackage2 resolved by manima@toy, on Thu Jun 27 11 : 12 : 18 2019, using Rez v2.32.1 requested packages : mypackage2 ~platform==windows (implicit) ~arch==AMD64 (implicit) ~os==windows-10.0.18362.SP0 (implicit) resolved packages : arch-AMD64 C : \\Users\\manima\\packages\\arch\\AMD64 (local) mypackage-1.3 C : \\Users\\manima\\packages\\mypackage\\1.3 (local) mypackage2-1.0 C : \\Users\\manima\\packages\\mypackage2\\1.0 (local) platform-windows C : \\Users\\manima\\packages\\platform\\windows (local) python-3.7.3 C : \\Users\\manima\\packages\\python\\3.7.3\\platform-windows\\arch-AMD64 (local) > $","title":"Requirements"},{"location":"rez/#payload","text":"Most packages will have additional files, such as Python modules. This is where build_command comes in. $ cd mypackage $ touch install.py # Additional script for build $ mkdir python # Payload directory $ cd python # $ echo print( \"Hello World!\" ) >> mymodule.py # Python payload shipped alongside package package.py name = \"mypackage\" version = \"1.3\" build_command = \"python {root}/install.py\" # Run this command on `rez build` requires = [ \"python-3\" ] def commands (): global env env[ \"PYTHONPATH\" ] . prepend( \"{root}/python\" ) # Add payload to environment install.py # This script is called on `rez build` import os import shutil print ( \"Running install.py...\" ) root = os . path . dirname(__file__) build_dir = os . environ[ \"REZ_BUILD_PATH\" ] install_dir = os . environ[ \"REZ_BUILD_INSTALL_PATH\" ] print ( \"Copying payload to %s..\" % build_dir) shutil . copytree( os . path . join(root, \"python\" ), os . path . join(build_dir, \"python\" ), ignore = shutil . ignore_patterns( \"*.pyc\" , \"__pycache__\" ) ) if int(os . getenv( \"REZ_BUILD_INSTALL\" )): # This part is called with `rez build --install` print ( \"Installing payload to %s...\" % install_dir) shutil . copytree( os . path . join(build_dir, \"python\" ), os . path . join(install_dir, \"python\" ), ) Now let's build it. $ rez build --install $ rez env mypackage > $ python -m mymodule Hello World!","title":"Payload"}]}